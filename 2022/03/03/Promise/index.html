<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="代码,博客" />
       
      <meta name="description" content="my blog" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Promise |  Welcome to jxx&#39;s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Promise"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Promise
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/03/Promise/" class="article-date">
  <time datetime="2022-03-03T06:11:53.000Z" itemprop="datePublished">2022-03-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">web前端学习笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">18 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <span id="more"></span>



<h1 id="第-1-章：Promise-的理解和使用"><a href="#第-1-章：Promise-的理解和使用" class="headerlink" title="第 1 章：Promise 的理解和使用"></a><strong>第</strong> <strong>1</strong> <strong>章：</strong>Promise <strong>的理解和使用</strong></h1><h2 id="1-1-Promise-是什么"><a href="#1-1-Promise-是什么" class="headerlink" title="1.1. Promise 是什么?"></a><strong>1.1. Promise</strong> <strong>是什么</strong>?</h2><h3 id="1-1-1-理解"><a href="#1-1-1-理解" class="headerlink" title="1.1.1. 理解"></a><strong>1.1.1.</strong> <strong>理解</strong></h3><ol>
<li>抽象表达: </li>
</ol>
<ol>
<li><p>Promise 是一门新的技术(ES6 规范)</p>
</li>
<li><p>Promise 是 JS 中进行异步编程的新解决方案</p>
</li>
</ol>
<p>备注：旧方案是单纯使用回调函数</p>
<ol start="2">
<li>具体表达:</li>
</ol>
<ol>
<li><p>从语法上来说: Promise 是一个构造函数</p>
</li>
<li><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/</p>
</li>
</ol>
<p>失败的结果值</p>
<h3 id="1-1-2-promise-的状态改变"><a href="#1-1-2-promise-的状态改变" class="headerlink" title="1.1.2. promise 的状态改变"></a><strong>1.1.2. promise</strong> <strong>的状态改变</strong></h3><ol>
<li><p>pending 变为 resolved</p>
</li>
<li><p>pending 变为 rejected</p>
</li>
</ol>
<p>说明: 只有这 2 种, 且一个 promise 对象只能改变一次</p>
<p> 无论变为成功还是失败, 都会有一个结果数据</p>
<p> 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason </p>
<h3 id="1-1-3-promise-的基本流程"><a href="#1-1-3-promise-的基本流程" class="headerlink" title="1.1.3. promise 的基本流程"></a><strong>1.1.3. promise</strong> <strong>的基本流程</strong></h3><h3 id="1-1-4-promise-的基本使用"><a href="#1-1-4-promise-的基本使用" class="headerlink" title="1.1.4. promise 的基本使用"></a><strong>1.1.4. promise</strong> <strong>的基本使用</strong></h3><ol>
<li>使用 1: 基本编码流程</li>
</ol>
<script>

// 1) 创建 promise 对象(pending 状态), 指定执行器函数

const p = new Promise((resolve, reject) => {

// 2) 在执行器函数中启动异步任务

setTimeout(() => {

const time = Date.now()

// 3) 根据结果做不同处理

// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态

if (time%2===1) {

resolve('成功的值 '+ time) 

} else { // 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为

rejected 状态

reject('失败的值' + time) 

}

}, 2000)

}) 



// 4) 能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason

p.then(

value => { // 成功的回调函数 onResolved, 得到成功的 vlaue

console.log('成功的 value: ', value)

},

reason => { // 失败的回调函数 onRejected, 得到失败的 reason

console.log('失败的 reason: ', reason) 

} 

)

</script>

<ol start="2">
<li>使用 2: 使用 promise 封装基于定时器的异步</li>
</ol>
<script>

function doDelay(time) {

// 1. 创建 promise 对象

return new Promise((resolve, reject) => {

// 2. 启动异步任务

console.log('启动异步任务')

setTimeout(() => {

console.log('延迟任务开始执行...')

const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败

if (time %2=== 1) { // 成功了

// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value

resolve('成功的数据 ' + time) 

} else { // 失败了

// 3.2. 如果失败了, 调用 reject()并传入失败的 reason

reject('失败的数据 ' + time) 

}

}, time)

})

}

const promise = doDelay(2000)

promise.then(

value => {

console.log('成功的 value: ', value)

},

reason => {

console.log('失败的 reason: ', reason)

},

)

</script>

<ol start="3">
<li>使用 3: 使用 promise 封装 ajax 异步请求</li>
</ol>
<script>

/*

可复用的发 ajax 请求的函数: xhr + promise

*/

function promiseAjax(url) {

return new Promise((resolve, reject) => {

const xhr = new XMLHttpRequest()

xhr.onreadystatechange = () => {

if (xhr.readyState!==4) return

const {status, response} = xhr

// 请求成功, 调用 resolve(value)

if (status>=200 && status<300) {

resolve(JSON.parse(response))

} else { // 请求失败, 调用 reject(reason)

reject(new Error('请求失败: status: ' + status))

} 

}

xhr.open("GET", url)

xhr.send()

}) 

}

promiseAjax('https://api.apiopen.top2/getJoke?page=1&count=2&type=video').then(

data => {

console.log('显示成功数据', data)

},

error => {

alert(error.message) 

} 

)

</script> 

<h2 id="1-2-为什么要用-Promise"><a href="#1-2-为什么要用-Promise" class="headerlink" title="1.2. 为什么要用 Promise?"></a><strong>1.2.</strong> <strong>为什么要用</strong> <strong>Promise?</strong></h2><h3 id="1-2-1-指定回调函数的方式更加灵活"><a href="#1-2-1-指定回调函数的方式更加灵活" class="headerlink" title="1.2.1. 指定回调函数的方式更加灵活"></a><strong>1.2.1.</strong> <strong>指定回调函数的方式更加灵活</strong></h3><ol>
<li><p>旧的: 必须在启动异步任务前指定</p>
</li>
<li><p>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函</p>
</li>
</ol>
<p>数(甚至可以在异步任务结束后指定/多个) </p>
<h3 id="1-2-2-支持链式调用-可以解决回调地狱问题"><a href="#1-2-2-支持链式调用-可以解决回调地狱问题" class="headerlink" title="1.2.2. 支持链式调用, 可以解决回调地狱问题"></a><strong>1.2.2.</strong> <strong>支持链式调用</strong><strong>,</strong> <strong>可以解决回调地狱问题</strong></h3><ol>
<li>什么是回调地狱? </li>
</ol>
<p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<ol start="2">
<li>回调地狱的缺点? </li>
</ol>
<p>不便于阅读</p>
<p>不便于异常处理</p>
<ol start="3">
<li>解决方案?</li>
</ol>
<p>promise 链式调用</p>
<ol start="4">
<li>终极解决方案?</li>
</ol>
<p>async/await</p>
<script>

/*

 1. 指定回调函数的方式更加灵活:

旧的: 必须在启动异步任务前指定

promise: 启动异步任务 => 返回 promie 对象 => 给 promise 对象绑定回调函数

(甚至可以在异步任务结束后指定)

 2. 支持链式调用, 可以解决回调地狱问题

什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函

数执行的条件

回调地狱的缺点? 不便于阅读 / 不便于异常处理

解决方案? promise 链式调用

终极解决方案? async/await

*/

// 成功的回调函数

function successCallback(result) {

console.log("声音文件创建成功: " + result);

}

// 失败的回调函数

function failureCallback(error) {

console.log("声音文件创建失败: " + error);

}

/* 1.1 使用纯回调函数 */

createAudioFileAsync(audioSettings, successCallback, failureCallback)

/* 1.2. 使用 Promise */

const promise = createAudioFileAsync(audioSettings); // 2

setTimeout(() => {

promise.then(successCallback, failureCallback);

}, 3000);

/*

2.1. 回调地狱

*/

doSomething(function(result) {

doSomethingElse(result, function(newResult) {

doThirdThing(newResult, function(finalResult) {

console.log('Got the final result: ' + finalResult)

}, failureCallback)

}, failureCallback)

}, failureCallback)

/*

2.2. 使用 promise 的链式调用解决回调地狱

*/

doSomething().then(function(result) {

return doSomethingElse(result)

})

.then(function(newResult) {

return doThirdThing(newResult)

})

.then(function(finalResult) {

console.log('Got the final result: ' + finalResult)

})

.catch(failureCallback)

/*

2.3. async/await: 回调地狱的终极解决方案

*/

async function request() { 

try {

const result = await doSomething()

const newResult = await doSomethingElse(result)

const finalResult = await doThirdThing(newResult)

console.log('Got the final result: ' + finalResult) 

} catch (error) {

failureCallback(error) 

} 

}

</script> 

<h2 id="1-3-如何使用-Promise"><a href="#1-3-如何使用-Promise" class="headerlink" title="1.3. 如何使用 Promise?"></a><strong>1.3.</strong> <strong>如何使用</strong> <strong>Promise?</strong></h2><h3 id="1-3-1-API"><a href="#1-3-1-API" class="headerlink" title="1.3.1. API"></a><strong>1.3.1. API</strong></h3><ol>
<li>Promise 构造函数: Promise (excutor) {}</li>
</ol>
<p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {} </p>
<p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}</p>
<p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}</p>
<p>说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行</p>
<ol start="2">
<li>Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</li>
</ol>
<p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}</p>
<p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p>
<p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调</p>
<p>返回一个新的 promise 对象</p>
<ol start="3">
<li>Promise.prototype.catch 方法: (onRejected) =&gt; {}</li>
</ol>
<p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {} </p>
<p> 说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
<ol start="4">
<li>Promise.resolve 方法: (value) =&gt; {}</li>
</ol>
<p>(1) value: 成功的数据或 promise 对象</p>
<p>说明: 返回一个成功/失败的 promise 对象</p>
<ol start="5">
<li>Promise.reject 方法: (reason) =&gt; {}</li>
</ol>
<p>(1) reason: 失败的原因</p>
<p>说明: 返回一个失败的 promise 对象</p>
<ol start="6">
<li>Promise.all 方法: (promises) =&gt; {}</li>
</ol>
<p>(1) promises: 包含 n 个 promise 的数组</p>
<p>说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就</p>
<p>直接失败</p>
<ol start="7">
<li>Promise.race 方法: (promises) =&gt; {}</li>
</ol>
<p>(1) promises: 包含 n 个 promise 的数组</p>
<p>说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p>
<script>

/*

 1. Promise 构造函数: Promise (excutor) {}

excutor 函数: 同步执行 (resolve, reject) => {}

resolve 函数: 内部定义成功时我们调用的函数 value => {}

reject 函数: 内部定义失败时我们调用的函数 reason => {}

说明: excutor 会在 Promise 内部立即同步回调,异步操作在执行器中执行

 2. Promise.prototype.then 方法: (onResolved, onRejected) => {}

onResolved 函数: 成功的回调函数 (value) => {} 

onRejected 函数: 失败的回调函数 (reason) => {}

说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调

返回一个新的 promise 对象

 3. Promise.prototype.catch 方法: (onRejected) => {}

onRejected 函数: 失败的回调函数 (reason) => {}

说明: then()的语法糖, 相当于: then(undefined, onRejected)

 4. Promise.resolve 方法: (value) => {}

value: 成功的数据或 promise 对象

说明: 返回一个成功/失败的 promise 对象

 5. Promise.reject 方法: (reason) => {}

reason: 失败的原因

说明: 返回一个失败的 promise 对象

 6. Promise.all 方法: (promises) => {}

promises: 包含 n 个 promise 的数组

说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一

个失败了就直接失败

 7. Promise.race 方法: (promises) => {}

promises: 包含 n 个 promise 的数组

说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的

结果状态

*/

/*

new Promise((resolve, reject) => {

if (Date.now()%2===0) {

resolve(1)

} else {

reject(2)

}

}).then(value => {

console.log('onResolved1()', value)

}).catch(reason => { 

 

 

11

 

console.log('onRejected1()', reason)

})

*/

const p1 = Promise.resolve(1)

const p2 = Promise.resolve(Promise.resolve(3))

const p3 = Promise.resolve(Promise.reject(5))

const p4 = Promise.reject(7)

const p5 = new Promise((resolve, reject) => {

setTimeout(() => {

if (Date.now()%2===0) {

resolve(1) 

} else {

reject(2) 

}

}, 100);

})

const pAll = Promise.all([p1, p2, p5])

pAll.then(

values => {console.log('all 成功了', values)},

reason => {console.log('all 失败了', reason)}

)

// const pRace = Promise.race([p5, p4, p1])

const pRace = Promise.race([p5, p1, p4])

pRace.then(

value => {console.log('race 成功了', value)},

reason => {console.log('race 失败了', reason)}

)

</script> 

<h3 id="1-3-2-promise-的几个关键问题"><a href="#1-3-2-promise-的几个关键问题" class="headerlink" title="1.3.2. promise 的几个关键问题"></a><strong>1.3.2. promise</strong> <strong>的几个关键问题</strong></h3><ol>
<li>如何改变 promise 的状态?</li>
</ol>
<p>(1) resolve(value): 如果当前是 pending 就会变为 resolved</p>
<p>(2) reject(reason): 如果当前是 pending 就会变为 rejected</p>
<p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p>
<ol start="2">
<li>一个 promise 指定多个成功/失败回调函数, 都会调用吗? </li>
</ol>
<p>当 promise 改变为对应状态时都会调用</p>
<ol start="3">
<li>改变 promise 状态和指定回调函数谁先谁后?</li>
</ol>
<p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p>
<p>(2) 如何先改状态再指定回调? </p>
<p>① 在执行器中直接调用 resolve()/reject()</p>
<p>② 延迟更长时间才调用 then()</p>
<p>(3) 什么时候才能得到数据? </p>
<p>① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</p>
<p>② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p>
<ol start="4">
<li>promise.then()返回的新 promise 的结果状态由什么决定?</li>
</ol>
<p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定</p>
<p>(2) 详细表达: </p>
<p>① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</p>
<p>② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p>
<p>③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p>
<ol start="5">
<li>promise 如何串连多个操作任务?</li>
</ol>
<p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用</p>
<p>(2) 通过 then 的链式调用串连多个同步/异步任务 </p>
<ol start="6">
<li>promise 异常传透?</li>
</ol>
<p>(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调, </p>
<p>(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理</p>
<ol start="7">
<li>中断 promise 链?</li>
</ol>
<p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p>
<p>(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象</p>
<h1 id="第-2-章：自定义-手写-Promise"><a href="#第-2-章：自定义-手写-Promise" class="headerlink" title="第 2 章：自定义(手写****)Promise"></a><strong>第</strong> <strong>2</strong> <strong>章：自定义</strong>(手写****)Promise</h1><h2 id="2-1-定义整体结构"><a href="#2-1-定义整体结构" class="headerlink" title="2.1. 定义整体结构"></a><strong>2.1.</strong> <strong>定义整体结构</strong></h2><p>/*</p>
<p>自定义 Promise</p>
<p>*/</p>
<p>(function (window) {</p>
<p>/*</p>
<p>Promise 构造函数</p>
<p>excutor: 内部同步执行的函数 (resolve, reject) =&gt; {}</p>
<p>*/</p>
<p>function Promise(excutor) { </p>
<p>}</p>
<p>/*</p>
<p>为 promise 指定成功/失败的回调函数</p>
<p>函数的返回值是一个新的 promise 对象</p>
<p>*/</p>
<p>Promise.prototype.then = function (onResolved, onRejected) { </p>
<p>} </p>
<p>/*</p>
<p>为 promise 指定失败的回调函数</p>
<p>是 then(null, onRejected)的语法糖</p>
<p>*/</p>
<p>Promise.prototype.catch = function (onRejected) { </p>
<p>}</p>
<p>/*</p>
<p>返回一个指定了成功 value 的 promise 对象</p>
<p>*/</p>
<p>Promise.resolve = function (value) { </p>
<p>}</p>
<p>/*</p>
<p>返回一个指定了失败 reason 的 promise 对象</p>
<p>*/</p>
<p>Promise.reject = function (reason) { </p>
<p>}</p>
<p>/*</p>
<p>返回一个 promise, 只有 promises 中所有 promise 都成功时, 才最终成功, 只要有一个失败就直接</p>
<p>失败</p>
<p>*/</p>
<p>Promise.all = function (promises) { </p>
<p>}</p>
<p>/*</p>
<p>返回一个 promise， 一旦某个 promise 解决或拒绝， 返回的 promise 就会解决或拒绝。</p>
<p>*/</p>
<p>Promise.race = function (promises) { </p>
<p>} </p>
<p>// 暴露构造函数</p>
<p>window.Promise = Promise</p>
<p>})(window) </p>
<h2 id="2-2-Promise-构造函数的实现"><a href="#2-2-Promise-构造函数的实现" class="headerlink" title="2.2. Promise 构造函数的实现"></a><strong>2.2. Promise</strong> <strong>构造函数的实现</strong></h2><p>/*</p>
<p>Promise 构造函数</p>
<p>excutor: 内部同步执行的函数 (resolve, reject) =&gt; {}</p>
<p>*/</p>
<p>function Promise(excutor) {</p>
<p>const self = this</p>
<p>self.status = ‘pending’ // 状态值, 初始状态为 pending, 成功了变为</p>
<p>resolved, 失败了变为 rejected</p>
<p>self.data = undefined // 用来保存成功 value 或失败 reason 的属性</p>
<p>self.callbacks = [] // 用来保存所有待调用的包含 onResolved 和 onRejected 回</p>
<p>调函数的对象的数组</p>
<p>/*</p>
<p>异步处理成功后应该调用的函数</p>
<p>value: 将交给 onResolve()的成功数据</p>
<p>*/</p>
<p>function resolve(value) {</p>
<p>if(self.status!==’pending’) { // 如果当前不是 pending, 直接结束</p>
<p>return</p>
<p>}</p>
<p>// 立即更新状态, 保存数据</p>
<p>self.status = ‘resolved’</p>
<p>self.data = value</p>
<p>// 异步调用所有待处理的 onResolved 成功回调函数</p>
<p>if (self.callbacks.length&gt;0) { </p>
<p>setTimeout(() =&gt; {</p>
<p>self.callbacks.forEach(obj =&gt; {</p>
<p>obj.onResolved(value)</p>
<p>})</p>
<p>})</p>
<p>} </p>
<p>}</p>
<p>/*</p>
<p>异步处理失败后应该调用的函数</p>
<p>reason: 将交给 onRejected()的失败数据</p>
<p>*/</p>
<p>function reject(reason) {</p>
<p>if(self.status!==’pending’) { // 如果当前不是 pending, 直接结束</p>
<p>return</p>
<p>}</p>
<p>// 立即更新状态, 保存数据</p>
<p>self.status = ‘rejected’</p>
<p>self.data = reason</p>
<p>// 异步调用所有待处理的 onRejected 回调函数</p>
<p>setTimeout(() =&gt; {</p>
<p>self.callbacks.forEach(obj =&gt; {</p>
<p>obj.onRejected(reason)</p>
<p>})</p>
<p>})</p>
<p>}</p>
<p>try {</p>
<p>// 立即同步调用 excutor()处理</p>
<p>excutor(resolve, reject) </p>
<p> } catch (error) { // 如果出了异常, 直接失败</p>
<p>reject(error) </p>
<p>} </p>
<p>}</p>
<h2 id="2-3-promise-then-catch-的实现"><a href="#2-3-promise-then-catch-的实现" class="headerlink" title="2.3. promise.then()/catch()的实现"></a>2.3. promise.then()/catch()的实现</h2><p>/*</p>
<p>为 promise 指定成功/失败的回调函数</p>
<p>函数的返回值是一个新的 promise 对象</p>
<p>*/</p>
<p>Promise.prototype.then = function (onResolved, onRejected) {</p>
<p>const self = this</p>
<p>// 如果 onResolved/onRejected 不是函数, 可它指定一个默认的函数</p>
<p>onResolved = typeof onResolved===’function’ ? onResolved : value =&gt; v</p>
<p>alue // 指定返回的 promise 为一个成功状态, 结果值为 value</p>
<p>onRejected = typeof onRejected === ‘function’ ? onRejected : reason = </p>
<blockquote>
<p>{throw reason} // 指定返回的 promise 为一个失败状态, 结果值为 reason</p>
</blockquote>
<p>// 返回一个新的 promise 对象</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>/*</p>
<p>专门抽取的用来处理 promise 成功/失败结果的函数</p>
<p>callback: 成功/失败的回调函数</p>
<p>*/</p>
<p>function handle(callback) {</p>
<p>// 1. 抛出异常 ===&gt; 返回的 promise 变为 rejected</p>
<p>try {</p>
<p>const x = callback(self.data)</p>
<p>// 2. 返回一个新的 promise ===&gt; 得到新的 promise 的结果值作为返回的</p>
<p>promise 的结果值</p>
<p>if (x instanceof Promise) { </p>
<p>x.then(resolve, reject) // 一旦 x 成功了, resolve(value), 一旦 x</p>
<p>失败了: reject(reason)</p>
<p>} else {</p>
<p>// 3. 返回一个一般值(undefined) ===&gt; 将这个值作为返回的 promise 的</p>
<p>成功值</p>
<p>resolve(x) </p>
<p>} </p>
<p>} catch (error) {</p>
<p>reject(error) </p>
<p>} </p>
<p>}</p>
<p>if (self.status === ‘resolved’) { // 当前 promise 已经成功了</p>
<p>setTimeout(() =&gt; {</p>
<p>handle(onResolved)</p>
<p>})</p>
<p>} else if (self.status === ‘rejected’) { // 当前 promise 已经失败了</p>
<p>setTimeout(() =&gt; {</p>
<p>handle(onRejected)</p>
<p>})</p>
<p>} else { // 当前 promise 还未确定 pending</p>
<p>// 将 onResolved 和 onRejected 保存起来</p>
<p>self.callbacks.push({</p>
<p>onResolved(value) {</p>
<p>handle(onResolved)</p>
<p>},</p>
<p>onRejected(reason) {</p>
<p>handle(onRejected) </p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>})</p>
<p>} </p>
<p>/*</p>
<p>为 promise 指定失败的回调函数</p>
<p>是 then(null, onRejected)的语法糖</p>
<p>*/</p>
<p>Promise.prototype.catch = function (onRejected) {</p>
<p>return this.then(null, onRejected) </p>
<p>}</p>
<h2 id="2-4-Promise-resolve-reject-的实现"><a href="#2-4-Promise-resolve-reject-的实现" class="headerlink" title="**2.4. Promise.resolve()/reject()**的实现"></a>**2.4. Promise.resolve()/reject()**的实现</h2><p>/*</p>
<p>返回一个指定了成功 value 的 promise 对象</p>
<p>value: 一般数据或 promise</p>
<p>*/</p>
<p>Promise.resolve = function (value) {</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>if (value instanceof Promise) {</p>
<p>value.then(resolve, reject) </p>
<p>} else {</p>
<p>resolve(value) </p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>/*</p>
<p>返回一个指定了失败 reason 的 promise 对象</p>
<p>reason: 一般数据/error</p>
<p>*/</p>
<p>Promise.reject = function (reason) {</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>reject(reason)</p>
<p>})</p>
<p>} </p>
<h2 id="2-5-Promise-all-race-的实现"><a href="#2-5-Promise-all-race-的实现" class="headerlink" title="**2.5. Promise.all/race()**的实现"></a>**2.5. Promise.all/race()**的实现</h2><p>/*</p>
<p>返回一个新的 promise 对象, 只有 promises 中所有 promise 都产生成功 value 时, 才</p>
<p>最终成功, 只要有一个失败就直接失败</p>
<p>*/</p>
<p>Promise.all = function (promises) {</p>
<p>// 返回一个新的 promise</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>// 已成功的数量</p>
<p>let resolvedCount = 0</p>
<p>// 待处理的 promises 数组的长度</p>
<p>const promisesLength = promises.length</p>
<p>// 准备一个保存成功值的数组</p>
<p>const values = new Array(promisesLength)</p>
<p>// 遍历每个待处理的 promise</p>
<p>for (let i = 0; i &lt; promisesLength; i++) {</p>
<p>// promises 中元素可能不是一个数组, 需要用 resolve 包装一下</p>
<p>Promise.resolve(promises[i]).then(</p>
<p>value =&gt; {</p>
<p>// 成功当前 promise 成功的值到对应的下标</p>
<p>values[i] = value</p>
<p>// 成功的数量加 1</p>
<p>resolvedCount++</p>
<p>// 一旦全部成功</p>
<p>if(resolvedCount===promisesLength) {</p>
<p>// 将所有成功值的数组作为返回 promise 对象的成功结果值</p>
<p>resolve(values) </p>
<p>}</p>
<p>},</p>
<p>reason =&gt; { </p>
<p>// 一旦有一个promise产生了失败结果值, 将其作为返回promise对象的失</p>
<p>败结果值</p>
<p>reject(reason) </p>
<p>} </p>
<p>) </p>
<p>}</p>
<p>})</p>
<p>}</p>
<p>/*</p>
<p>返回一个 promise，一旦某个 promise 解决或拒绝， 返回的 promise 就会解决或拒绝。</p>
<p>*/</p>
<p>Promise.race = function (promises) {</p>
<p>// 返回新的 promise 对象</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>// 遍历所有 promise</p>
<p>for (var i = 0; i &lt; promises.length; i++) {</p>
<p>Promise.resolve(promises[i]).then( </p>
<p>(value) =&gt; { // 只要有一个成功了, 返回的 promise 就成功了</p>
<p>resolve(value)</p>
<p>},</p>
<p>(reason) =&gt; { // 只要有一个失败了, 返回的结果就失败了</p>
<p>reject(reason) </p>
<p>} </p>
<p>) </p>
<p>}</p>
<p>})</p>
<p>}</p>
<h2 id="2-6-Promise-resolveDelay-rejectDelay-的实现"><a href="#2-6-Promise-resolveDelay-rejectDelay-的实现" class="headerlink" title="**2.6. Promise.resolveDelay()/rejectDelay()**的实现"></a>**2.6. Promise.resolveDelay()/rejectDelay()**<strong>的实现</strong></h2><p>/*</p>
<p>返回一个延迟指定时间才确定结果的 promise 对象 </p>
<p>*/</p>
<p>Promise.resolveDelay = function (value, time) {</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>setTimeout(() =&gt; {</p>
<p>if (value instanceof Promise) { // 如果 value 是一个 promise, 取这个</p>
<p>promise 的结果值作为返回的 promise 的结果值</p>
<p>value.then(resolve, reject) // 如果 value 成功, 调用</p>
<p>resolve(val), 如果 value 失败了, 调用 reject(reason)</p>
<p>} else {</p>
<p>resolve(value) </p>
<p>}</p>
<p>}, time);</p>
<p>})</p>
<p>}</p>
<p>/*</p>
<p>返回一个延迟指定时间才失败的 Promise 对象。</p>
<p>*/</p>
<p>Promise.rejectDelay = function (reason, time) {</p>
<p>return new Promise((resolve, reject) =&gt; {</p>
<p>setTimeout(() =&gt; {</p>
<p>reject(reason)</p>
<p>}, time)</p>
<p>})</p>
<p>}</p>
<h2 id="2-7-ES5-function-完整版本"><a href="#2-7-ES5-function-完整版本" class="headerlink" title="2.7. ES5 function 完整版本"></a><strong>2.7. ES5 function</strong> <strong>完整版本</strong></h2><p>Promise.js </p>
<h2 id="2-8-ES6-class-完整版"><a href="#2-8-ES6-class-完整版" class="headerlink" title="2.8. ES6 class 完整版"></a><strong>2.8. ES6 class</strong> <strong>完整版</strong></h2><h1 id="第-3-章：-async-与-await"><a href="#第-3-章：-async-与-await" class="headerlink" title="第 3 章：****async 与 await"></a><strong>第</strong> <strong>3</strong> <strong>章：****async</strong> <strong>与</strong> <strong>await</strong></h1><h2 id="3-1-mdn-文档"><a href="#3-1-mdn-文档" class="headerlink" title="3.1. mdn 文档"></a><strong>3.1. mdn</strong> <strong>文档</strong></h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await</a></p>
<h2 id="3-2-async-函数"><a href="#3-2-async-函数" class="headerlink" title="3.2. async 函数"></a><strong>3.2. async</strong> <strong>函数</strong></h2><ol>
<li><p>函数的返回值为 promise 对象</p>
</li>
<li><p>promise 对象的结果由 async 函数执行的返回值决定</p>
</li>
</ol>
<h2 id="3-3-await-表达式"><a href="#3-3-await-表达式" class="headerlink" title="3.3. await 表达式"></a><strong>3.3. await</strong> <strong>表达式</strong></h2><ol>
<li><p>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</p>
</li>
<li><p>如果表达式是 promise 对象, await 返回的是 promise 成功的值</p>
</li>
<li><p>如果表达式是其它值, 直接将此值作为 await 的返回值</p>
</li>
</ol>
<h2 id="3-4-注意"><a href="#3-4-注意" class="headerlink" title="3.4. 注意"></a><strong>3.4.</strong> <strong>注意</strong></h2><ol>
<li><p>await 必须写在 async 函数中, 但 async 函数中可以没有 await</p>
</li>
<li><p>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</p>
</li>
</ol>
<script>

Promise_class.js 

function fn1() {

return Promise.resolve(1) 

}

function fn2() {

return 2 

}

function fn3() {

return Promise.reject(3)

// return fn3.test() // 程序运行会抛出异常

}

function fn4() {

return fn3.test() // 程序运行会抛出异常

}

// 没有使用 await 的 async 函数

async function fn5() {

return 4 

}

async function fn() {

// await 右侧是一个成功的 promise

const result = await fn1()

// await 右侧是一个非 promise 的数据

// const result = await fn2()

// await 右侧是一个失败的 promise

// const result = await fn3()

// await 右侧抛出异常

// const result = await fn4()

console.log('result: ', result) ****

 

return result+10

}

async function test() {

try {

const result2 = await fn()

console.log('result2', result2) 

} catch (error) {

console.log('error', error) 

}

const result3 = await fn4()

console.log('result4', result3) 

}

// test()

</script> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/03/03/Promise/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/03/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">算法笔记之字符串篇</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Jxx-sixhh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Welcome to jxx&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/web%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Web前端知识</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1873321491&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>